(require 'cl) ; If you don't have it already

(defun* get-closest-pathname (&optional (max-level 3) (file "Makefile"))
  (let ((root (expand-file-name "/"))
        (level 0))
    (expand-file-name file
                      (loop
                       for d = default-directory then (expand-file-name ".." d)
                       do (setq level (+ level 1))
                       if (file-exists-p (expand-file-name file d))
                       return d
                       if (> level max-level)
                       return nil
                       if (equal d root)
                       return nil))))


(defun my-compile-command () 
	(unless (file-exists-p "Makefile")
              (set (make-local-variable 'compile-command)
                   (let ((file (file-name-nondirectory buffer-file-name))
                         (mkfile (get-closest-pathname)))
                     (if mkfile
                         (progn (format "cd %s; make -f %s"
                            (file-name-directory mkfile) mkfile))
                       (format "%s -c -o %s.o %s %s %s"
                               (or (getenv "CC") "gcc")
                               (file-name-sans-extension file)
                               (or (getenv "CPPFLAGS") "-DDEBUG=9")
                               (or (getenv "CFLAGS") "-ansi -pedantic -Wall -g")
                               file)))))  
)
(add-hook 'c++-mode-hook my-compile-command)
(add-hook 'c-mode-hook my-compile-command)

